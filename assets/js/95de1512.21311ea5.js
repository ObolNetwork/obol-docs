"use strict";(self.webpackChunkobol_docs=self.webpackChunkobol_docs||[]).push([[21427],{98621:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>n,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"dvk/distributed-validator-keys","title":"Distributed validator keys","description":"A distributed validator key is a group of BLS private keys that together operate as a threshold key for participating in proof-of-stake consensus.","source":"@site/versioned_docs/version-v0.3.0/dvk/01_distributed-validator-keys.md","sourceDirName":"dvk","slug":"/dvk/distributed-validator-keys","permalink":"/v0.3.0/dvk/distributed-validator-keys","draft":false,"unlisted":false,"editUrl":"https://github.com/ObolNetwork/obol-docs/edit/main/versioned_docs/version-v0.3.0/dvk/01_distributed-validator-keys.md","tags":[],"version":"v0.3.0","sidebarPosition":1,"frontMatter":{"Description":"An Effort to Accelerate and Standardise the Generation of Distributed Validators"},"sidebar":"tutorialSidebar","previous":{"title":"Charon CLI reference","permalink":"/v0.3.0/dv/charon_cli_reference"},"next":{"title":"Distributed validator launchpad","permalink":"/v0.3.0/dvk/distributed_validator_launchpad"}}');var a=r(74848),o=r(28453);const n={Description:"An Effort to Accelerate and Standardise the Generation of Distributed Validators"},s="Distributed validator keys",d={},c=[];function l(e){const t={a:"a",h1:"h1",header:"header",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"distributed-validator-keys",children:"Distributed validator keys"})}),"\n",(0,a.jsx)(t.p,{children:"A distributed validator key is a group of BLS private keys that together operate as a threshold key for participating in proof-of-stake consensus."}),"\n",(0,a.jsxs)(t.p,{children:["To achieve fault tolerance in a distributed validator, the individual private key shares need to be generated together. Rather than have a trusted dealer produce a private key, split it and distribute it, the preferred approach is to never construct the full private key at any point, by having each operator in the distributed validator cluster participate in what is known as a ",(0,a.jsx)(t.strong,{children:"distributed key generation ceremony"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"A distributed validator key generation ceremony is a type of DKG ceremony. A DVK ceremony produces signed validator deposit and exit data, along with all of the validator key shares and their associated metadata."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"There is currently an active working group developing DKG."})," Further information can be seen on the ",(0,a.jsx)(t.a,{href:"/v0.3.0/int/working-groups",children:"working groups"})," page."]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>n,x:()=>s});var i=r(96540);const a={},o=i.createContext(a);function n(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);