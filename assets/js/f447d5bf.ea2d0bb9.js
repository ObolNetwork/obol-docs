"use strict";(self.webpackChunkobol_docs=self.webpackChunkobol_docs||[]).push([[55408],{81031:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var n=i(74848),o=i(28453);const r={description:"How do distributed validator clients communicate with one another securely?",sidebar_position:4},s="Peer discovery",a={id:"charon/peer-discovery",title:"Peer discovery",description:"How do distributed validator clients communicate with one another securely?",source:"@site/versioned_docs/version-v0.13.0/charon/peer-discovery.md",sourceDirName:"charon",slug:"/charon/peer-discovery",permalink:"/docs/v0.13.0/charon/peer-discovery",draft:!1,unlisted:!1,editUrl:"https://github.com/ObolNetwork/obol-docs/edit/main/versioned_docs/version-v0.13.0/charon/peer-discovery.md",tags:[],version:"v0.13.0",sidebarPosition:4,frontMatter:{description:"How do distributed validator clients communicate with one another securely?",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Cluster Configuration",permalink:"/docs/v0.13.0/charon/cluster-configuration"},next:{title:"P2P interface",permalink:"/docs/v0.13.0/charon/p2p-interface"}},c={},d=[{value:"Authenticating a distributed validator client",id:"authenticating-a-distributed-validator-client",level:2},{value:"Node database",id:"node-database",level:2},{value:"Node discovery",id:"node-discovery",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"peer-discovery",children:"Peer discovery"})}),"\n",(0,n.jsx)(t.p,{children:"In order to maintain security and sybil-resistance, charon clients need to be able to authenticate one another. We achieve this by giving each charon client a public/private key pair that they can sign with such that other clients in the cluster will be able to recognise them as legitimate no matter which IP address they communicate from."}),"\n",(0,n.jsx)(t.h2,{id:"authenticating-a-distributed-validator-client",children:"Authenticating a distributed validator client"}),"\n",(0,n.jsxs)(t.p,{children:["Before a DKG process begins, all operators must run ",(0,n.jsx)(t.a,{href:"/docs/v0.13.0/charon/charon_cli_reference#creating-an-enr-for-charon",children:(0,n.jsx)(t.code,{children:"charon create enr"})}),", or just ",(0,n.jsx)(t.code,{children:"charon enr"}),", to create or get the Ethereum Node Record for their client. These ENRs are included in the configuration of a Distributed Key Generation ceremony."]}),"\n",(0,n.jsxs)(t.p,{children:["The file that outlines a DKG ceremony is known as a ",(0,n.jsx)(t.a,{href:"./cluster-configuration",children:(0,n.jsx)(t.code,{children:"cluster-definition.json"})})," file. This file is passed to ",(0,n.jsx)(t.code,{children:"charon dkg"})," which uses it to create private keys, a ",(0,n.jsx)(t.a,{href:"./cluster-configuration",children:(0,n.jsx)(t.code,{children:"cluster-lock.json"})})," file and ",(0,n.jsx)(t.code,{children:"deposit-data.json"})," for the configured number of distributed validators. The ",(0,n.jsx)(t.code,{children:"cluster-lock"})," file will be made available to ",(0,n.jsx)(t.code,{children:"charon run"}),", and the validator key stores will be made available to the configured validator client."]}),"\n",(0,n.jsxs)(t.p,{children:["When ",(0,n.jsx)(t.a,{href:"/docs/v0.13.0/charon/charon_cli_reference#run-the-charon-middleware",children:(0,n.jsx)(t.code,{children:"charon run"})})," starts up and ingests its configuration from the ",(0,n.jsx)(t.code,{children:"cluster-lock.json"})," file, it checks if its observed/configured public IP address differs from what is listed in the lock file. If it is different; it updates the IP address, increments the nonce of the ENR and reissues it before beginning to establish connections with the other operators in the cluster."]}),"\n",(0,n.jsx)(t.h2,{id:"node-database",children:"Node database"}),"\n",(0,n.jsx)(t.p,{children:"Distributed Validator Clusters are permissioned networks with a fully meshed topology. Each node will permanently store the ENRs of all other known Obol nodes in their node database."}),"\n",(0,n.jsxs)(t.p,{children:["Unlike with node databases of public permissionless networks (such as ",(0,n.jsx)(t.a,{href:"https://pkg.go.dev/github.com/ethereum/go-ethereum@v1.10.13/p2p/enode#DB",children:"Go-Ethereum"}),"), there is no inbuilt eviction logic \u2013 the database will keep growing indefinitely. This is acceptable as the number of operators in a cluster is expected to stay constant. Mutable cluster operators will be introduced in future."]}),"\n",(0,n.jsx)(t.h2,{id:"node-discovery",children:"Node discovery"}),"\n",(0,n.jsxs)(t.p,{children:["At boot, a charon client will ingest its configured ",(0,n.jsx)(t.code,{children:"cluster-lock.json"})," file. This file contains a list of ENRs of the client's peers. The client will attempt to establish a connection with these peers, and will perform a handshake if they connect to establish an end to end encrypted communication channel between the clients."]}),"\n",(0,n.jsxs)(t.p,{children:["However, the IP addresses within an ENR can become stale. This could result in a cluster not being able to establish a connection with all nodes. To be tolerant to operator IP addresses changing, charon also supports the ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md",children:"discv5"})," discovery protocol. This allows a charon client to find another operator that might have moved IP address, but still retains the same ENR private key."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(96540);const o={},r=n.createContext(o);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);