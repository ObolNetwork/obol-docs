"use strict";(self.webpackChunkobol_docs=self.webpackChunkobol_docs||[]).push([[5749],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),d=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||r;return n?o.createElement(m,i(i({ref:t},c),{},{components:n})):o.createElement(m,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},68748:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return p}});var o=n(83117),a=n(80102),r=(n(67294),n(3905)),i=["components"],l={sidebar_position:2,description:"Run one node in a multi-operator distributed validator cluster using the CLI"},s="CLI",d={unversionedId:"int/quickstart/group/quickstart-group-cli",id:"int/quickstart/group/quickstart-group-cli",title:"CLI",description:"Run one node in a multi-operator distributed validator cluster using the CLI",source:"@site/docs/int/quickstart/group/quickstart-group-cli.md",sourceDirName:"int/quickstart/group",slug:"/int/quickstart/group/quickstart-group-cli",permalink:"/docs/next/int/quickstart/group/quickstart-group-cli",draft:!1,editUrl:"https://github.com/ObolNetwork/obol-docs/edit/main/docs/int/quickstart/group/quickstart-group-cli.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Run one node in a multi-operator distributed validator cluster using the CLI"},sidebar:"tutorialSidebar",previous:{title:"Launchpad",permalink:"/docs/next/int/quickstart/group/quickstart-group-launchpad"},next:{title:"Run a cluster alone",permalink:"/docs/next/int/quickstart/quickstart-alone"}},c={},p=[{value:"Pre-requisites",id:"pre-requisites",level:2},{value:"Step 1. Creating and backing up a private key for charon",id:"step-1-creating-and-backing-up-a-private-key-for-charon",level:2},{value:"Step 2. Leader creates the DKG configuration file and distributes it to cluster operators",id:"step-2-leader-creates-the-dkg-configuration-file-and-distributes-it-to-cluster-operators",level:2},{value:"Step 3. Run the DKG",id:"step-3-run-the-dkg",level:2},{value:"Step 4. Start the Distributed Validator Cluster",id:"step-4-start-the-distributed-validator-cluster",level:2},{value:"Step 5. Activate the deposit data",id:"step-5-activate-the-deposit-data",level:2},{value:"Step 6. Leader Adds Central Monitoring Token",id:"step-6-leader-adds-central-monitoring-token",level:2},{value:"Validator Voluntary Exit",id:"validator-voluntary-exit",level:2},{value:"Self-Host a Bootnode",id:"self-host-a-bootnode",level:2}],u={toc:p};function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cli"},"CLI"),(0,r.kt)("p",null,"The following instructions aim to assist a group of users coordinating together to create a distributed validator cluster between them."),(0,r.kt)("h2",{id:"pre-requisites"},"Pre-requisites"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ensure you have ",(0,r.kt)("a",{parentName:"li",href:"https://docs.docker.com/engine/install/"},"docker")," and ",(0,r.kt)("a",{parentName:"li",href:"https://git-scm.com/downloads"},"git")," installed. Also, make sure ",(0,r.kt)("inlineCode",{parentName:"li"},"docker")," is running before executing the commands below."),(0,r.kt)("li",{parentName:"ul"},"Decide who the leader of your cluster will be. Only leaders have to perform ",(0,r.kt)("a",{parentName:"li",href:"#step-2-leader-creates-the-dkg-configuration-file-and-distributes-it-to-everyone-else"},"step 2")," and ",(0,r.kt)("a",{parentName:"li",href:"#step-5-activate-the-deposit-data"},"step 5")," in the quickstart process. They do not get any special privilege.")),(0,r.kt)("h2",{id:"step-1-creating-and-backing-up-a-private-key-for-charon"},"Step 1. Creating and backing up a private key for charon"),(0,r.kt)("p",null,"The first step of running a cluster is preparing for a distributed key generation ceremony. To do this everyone must create an ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/int/faq/errors#what-is-an-enr"},"ENR")," for their charon client. This ENR is a public/private key pair, and allows the other charon clients in the DKG to identify and connect to your node."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'# Clone this repo\ngit clone https://github.com/ObolNetwork/charon-distributed-validator-node.git\n\n# Change directory\ncd charon-distributed-validator-node\n\n# Create your charon ENR private key, this will create a charon-enr-private-key file in the .charon directory\ndocker run --rm -v "$(pwd):/opt/charon" obolnetwork/charon:v0.11.0 create enr\n')),(0,r.kt)("p",null,"You should expect to see a console output like"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Created ENR private key: .charon/charon-enr-private-key\nenr:-JG4QGQpV4qYe32QFUAbY1UyGNtNcrVMip83cvJRhw1brMslPeyELIz3q6dsZ7GblVaCjL_8FKQhF6Syg-O_kIWztimGAYHY5EvPgmlkgnY0gmlwhH8AAAGJc2VjcDI1NmsxoQKzMe_GFPpSqtnYl-mJr8uZAUtmkqccsAx7ojGmFy-FY4N0Y3CCDhqDdWRwgg4u\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Attention"),(0,r.kt)("p",{parentName:"blockquote"},"Please make sure to create a backup of the private key at ",(0,r.kt)("inlineCode",{parentName:"p"},".charon/charon-enr-private-key"),". Be careful not to commit it to git! ",(0,r.kt)("strong",{parentName:"p"},"If you lose this file you won't be able to take part in the DKG ceremony."))),(0,r.kt)("p",null,"If you are taking part in an organised Obol testnet, submit the created ENR public address (the console output starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"enr:-...")," not the contents of the private key file) to the appropriate typeform."),(0,r.kt)("h2",{id:"step-2-leader-creates-the-dkg-configuration-file-and-distributes-it-to-cluster-operators"},"Step 2. Leader creates the DKG configuration file and distributes it to cluster operators"),(0,r.kt)("p",null,"The leader will prepare the ",(0,r.kt)("inlineCode",{parentName:"p"},"cluster-definition.json")," file for the Distributed Key Generation ceremony using the ",(0,r.kt)("inlineCode",{parentName:"p"},"charon create dkg")," command."),(0,r.kt)("p",null,"In future, step 1 and step 2 of this guide will use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.obol.tech/docs/dvk/distributed_validator_launchpad"},"Obol Distributed Validator Launchpad")," to facilitate and verify these files are created in an authenticated manner."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'# Prepare an environment variable file\ncp .env.create_dkg.sample .env.create_dkg\n\n# Populate the .env.create_dkg file with the cluster name, the fee recipient and withdrawal Ethereum addresses and the \n# operator ENRs of all the operators participating in the DKG ceremony.\n\n# Run the `charon create dkg` command that generates DKG cluster-definition.json file.\ndocker run --rm -v "$(pwd):/opt/charon" --env-file .env.create_dkg obolnetwork/charon:v0.11.0 create dkg\n')),(0,r.kt)("p",null,"This command should output a file at ",(0,r.kt)("inlineCode",{parentName:"p"},".charon/cluster-definition.json"),". This file needs to be shared with the other operators in a cluster."),(0,r.kt)("h2",{id:"step-3-run-the-dkg"},"Step 3. Run the DKG"),(0,r.kt)("p",null,"After receiving the ",(0,r.kt)("inlineCode",{parentName:"p"},"cluster-definition.json")," file created by the leader, cluster members should ideally save it in the ",(0,r.kt)("inlineCode",{parentName:"p"},".charon/")," folder that was created during step 1, alternatively the ",(0,r.kt)("inlineCode",{parentName:"p"},"--definition-file")," flag can override the default expected location for this file."),(0,r.kt)("p",null,"Every cluster member then participates in the DKG ceremony. For Charon v1, this needs to happen synchronously between participants at an agreed time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'# Participate in DKG ceremony, this will create .charon/cluster-lock.json, .charon/deposit-data.json and .charon/validator_keys\ndocker run --rm -v "$(pwd):/opt/charon" obolnetwork/charon:v0.11.0 dkg --p2p-bootnode-relay\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This is a helpful ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=94Pkovp5zoQ&ab_channel=ObolNetwork"},"video walkthrough"),".")),(0,r.kt)("p",null,"Assuming the DKG is successful, a number of artefacts will be created in the ",(0,r.kt)("inlineCode",{parentName:"p"},".charon")," folder. These include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"deposit-data.json")," file. This contains the information needed to activate the validator on the Ethereum network."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"cluster-lock.json")," file. This contains the information needed by charon to operate the distributed validator cluster with its peers."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"validator_keys/")," folder. This folder contains the private key shares and passwords for the created distributed validators.")),(0,r.kt)("p",null,"At this point you should make a backup of the ",(0,r.kt)("inlineCode",{parentName:"p"},".charon/validator_keys")," folder as replacing lost private keys is not straightforward at this point in charon's development. The ",(0,r.kt)("inlineCode",{parentName:"p"},"cluster-lock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit-data")," files are identical for each operator and can be copied if lost."),(0,r.kt)("p",null,"If taking part in an official Obol testnet, one cluster member will have to submit the ",(0,r.kt)("inlineCode",{parentName:"p"},"cluster-lock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit-data")," files to the Obol Team."),(0,r.kt)("h2",{id:"step-4-start-the-distributed-validator-cluster"},"Step 4. Start the Distributed Validator Cluster"),(0,r.kt)("p",null,"With the DKG ceremony over, the last phase before activation is to prepare your node for validating over the long term. This repo is configured to sync an execution layer client (",(0,r.kt)("inlineCode",{parentName:"p"},"nethermind"),") and a consensus layer client (",(0,r.kt)("inlineCode",{parentName:"p"},"nimbus"),")."),(0,r.kt)("p",null,"Before completing these instructions, you should assign a static local IP address to your device (extending the DHCP reservation indefinitely or removing the device from the DCHP pool entirely if you prefer), and port forward the TCP protocol on the public port ",(0,r.kt)("inlineCode",{parentName:"p"},":3610")," on your router to your device's local IP address on the same port. This step is different for every person's home internet, and can be complicated by the presence of dynamic public IP addresses. We are currently working on making this as easy as possible, but for the time being, a distributed validator cluster isn't going to work very resiliently if all charon nodes cannot talk directly to one another and instead need to have an intermediary node forwarding traffic to them."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Caution"),": If you manually update ",(0,r.kt)("inlineCode",{parentName:"p"},"docker-compose")," to mount ",(0,r.kt)("inlineCode",{parentName:"p"},"lighthouse")," from your locally synced ",(0,r.kt)("inlineCode",{parentName:"p"},"~/.lighthouse"),", the whole chain database may get deleted. It'd be best not to manually update as ",(0,r.kt)("inlineCode",{parentName:"p"},"lighthouse")," checkpoint-syncs so the syncing doesn't take much time."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE"),": If you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"geth")," node already synced, you can simply copy over the directory. For ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"cp -r ~/.ethereum/goerli data/geth"),". This makes everything faster since you start from a synced geth node."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# Delete lighthouse data if it exists\nrm -r ./data/lighthouse\n\n# Spin up a Distributed Validator Node with a Validator Client\ndocker-compose up\n\n# Open Grafana dashboard\nopen http://localhost:3000/d/singlenode/\n")),(0,r.kt)("p",null,"You should use the grafana dashboard to infer whether your cluster is healthy. In particular you should check:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"That your charon client can connect to the configured beacon client."),(0,r.kt)("li",{parentName:"ul"},"That your charon client can connect to all peers")),(0,r.kt)("p",null,"Most components in the dashboard have some help text there to assist you in understanding your cluster performance."),(0,r.kt)("p",null,"You might notice that there are logs indicating that a validator cannot be found and that APIs are returning 404. This is to be expected at this point, as the validator public keys listed in the lock file have not been deposited and acknowledged on the consensus layer yet (usually ~16 hours after the deposit is made)."),(0,r.kt)("p",null,"To turn off your node after checking the health of the cluster you can run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# Shut down the currently running distributed validator node\ndocker-compose down\n")),(0,r.kt)("h2",{id:"step-5-activate-the-deposit-data"},"Step 5. Activate the deposit data"),(0,r.kt)("p",null,"If you and your team have gotten to this phase of the quickstart, and you have successfully created a distributed validator together, and you have connected all of your charon clients together such that the monitoring indicates that they are all healthy and ready to operate, one person may process to activate this deposit data with the existing ",(0,r.kt)("a",{parentName:"p",href:"https://prater.launchpad.ethereum.org/"},"staking launchpad"),"."),(0,r.kt)("p",null,"This process can take a minimum of 16 hours, with the maximum time to activation being dictated by the length of the activation queue, which can be weeks. You can leave your distributed validator cluster offline until closer to the activation period if you would prefer. You can also use this time to improve and harden your monitoring and alerting for the cluster."),(0,r.kt)("p",null,"If you have gotten this far through the process, and whether you succeed or fail at running the distributed validator successfully on the testnet, we would like to hear your feedback on the process and where you encountered difficulties. Please let us know by joining and posting on our ",(0,r.kt)("a",{parentName:"p",href:"https://discord.gg/TsXFa8uB2E"},"Discord"),". Also, feel free to add issues to our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ObolNetwork"},"GitHub repos"),"."),(0,r.kt)("h1",{id:"other-optional-actions"},"Other Optional Actions"),(0,r.kt)("p",null,"The above steps should get you running a distributed validator cluster. The following are some extra steps you may want to take either to help Obol with their testing program, or to improve the resilience and performance of your distributed validator cluster."),(0,r.kt)("h2",{id:"step-6-leader-adds-central-monitoring-token"},"Step 6. Leader Adds Central Monitoring Token"),(0,r.kt)("p",null,"The cluster leader may be provided with a Central Monitoring Token used to push distributed validator metrics to our central prometheus service to monitor, analyze and improve your cluster's performance. The token needs to be added in prometheus/prometheus.yml replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"$PROM_REMOTE_WRITE_TOKEN"),". The token will look like:\n",(0,r.kt)("inlineCode",{parentName:"p"},"eyJtZXNzYWdlIjoiSldUIFJ1bGVzISIsImlhdCI6MTQ1OTQ0ODExOSwiZXhwIjoxNDU5NDU0NTE5fQ"),"."),(0,r.kt)("p",null,"Final prometheus/prometheus.yml would look something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"global:\n  scrape_interval:     30s # Set the scrape interval to every 30 seconds.\n  evaluation_interval: 30s # Evaluate rules every 30 seconds.\n\nremote_write:\n  - url: https://vm.monitoring.gcp.obol.tech/write\n    authorization:\n      credentials: eyJtZXNzYWdlIjoiSldUIFJ1bGVzISIsImlhdCI6MTQ1OTQ0ODExOSwiZXhwIjoxNDU5NDU0NTE5fQ\n\nscrape_configs:\n  - job_name: 'charon'\n    static_configs:\n      - targets: ['charon:3620']\n  - job_name: 'teku'\n    static_configs:\n      - targets: ['teku:8008']\n  - job_name: 'node-exporter'\n    static_configs:\n      - targets: ['node-exporter:9100']\n")),(0,r.kt)("h2",{id:"validator-voluntary-exit"},"Validator Voluntary Exit"),(0,r.kt)("p",null,"A voluntary exit is when a validator chooses to stop performing its duties, and exits the beacon chain permanently. To voluntarily exit, the validator must continue performing its validator duties until successfully exited to avoid penalties."),(0,r.kt)("p",null,"To trigger a voluntary exit, a sidecar docker-compose command is executed that signs and submits the voluntary exit to the active running charon node that shares it with other nodes in the cluster. The commands below should be executed on the same machine and same folder as the active running ",(0,r.kt)("inlineCode",{parentName:"p"},"charon-distribute-validator-node")," docker compose."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"A threshold of peers in the cluster need to perform this task to exit a validator.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a new ",(0,r.kt)("inlineCode",{parentName:"li"},"exit_keys")," folder next to ",(0,r.kt)("inlineCode",{parentName:"li"},".charon/validator_keys"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"mkdir .charon/exit_keys")),(0,r.kt)("li",{parentName:"ul"},"Copy the validator keys and passwords that you want to exit from the ",(0,r.kt)("inlineCode",{parentName:"li"},"validator_keys")," folder to the ",(0,r.kt)("inlineCode",{parentName:"li"},"exit_keys")," folder.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"E.g. to exit validator #4: ",(0,r.kt)("inlineCode",{parentName:"li"},"cp .charon/validator_keys/keystore/keystore-4* .charon/exit_keys/")),(0,r.kt)("li",{parentName:"ul"},"Warning: all keys copied to the ",(0,r.kt)("inlineCode",{parentName:"li"},"exit_keys")," folder will be exited, so be careful!"))),(0,r.kt)("li",{parentName:"ul"},"Ensure the external network in ",(0,r.kt)("inlineCode",{parentName:"li"},"compose-volutary-exit.yml")," is correct.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Confirm the name of the exiting ",(0,r.kt)("inlineCode",{parentName:"li"},"charon-distributed-validator-node")," docker network: ",(0,r.kt)("inlineCode",{parentName:"li"},"docker network ls"),"."),(0,r.kt)("li",{parentName:"ul"},"If it isn't ",(0,r.kt)("inlineCode",{parentName:"li"},"charon-distributed-validator-node-dvnode"),", then update ",(0,r.kt)("inlineCode",{parentName:"li"},"compose-volutary-exit.yml")," accordingly."))),(0,r.kt)("li",{parentName:"ul"},"Ensure the latest fork version epoch is used:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Voluntary exists require an epoch after which they take effect."),(0,r.kt)("li",{parentName:"ul"},"All VCs need to sign and submit the exact same messages (epoch) in DVT."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"--epoch=1")," would be ideal, since all chains have that epoch in the past, so the validator should exit immediately."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"compose-volutary-exit.yml")," is configured with ",(0,r.kt)("inlineCode",{parentName:"li"},"--epoch=112260")," which is the latest Bellatrix fork on Prater."),(0,r.kt)("li",{parentName:"ul"},"If the Charon cluster is running on a different chain, ",(0,r.kt)("strong",{parentName:"li"},"ALL")," operators must update ",(0,r.kt)("inlineCode",{parentName:"li"},"--epoch")," to the same latest fork version returned by ",(0,r.kt)("inlineCode",{parentName:"li"},"curl $BEACON_NODE/eth/v1/config/fork_schedule"),"."))),(0,r.kt)("li",{parentName:"ul"},"Run the command to submit this node's partially signed voluntary exit:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"docker-compose -f compose-voluntary-exit.yml up")),(0,r.kt)("li",{parentName:"ul"},"Confirm the logs: ",(0,r.kt)("inlineCode",{parentName:"li"},"Exit for validator XXXXX submitted")),(0,r.kt)("li",{parentName:"ul"},"Exit the container: ",(0,r.kt)("inlineCode",{parentName:"li"},"Ctrl-C")))),(0,r.kt)("li",{parentName:"ul"},"The charon metric ",(0,r.kt)("inlineCode",{parentName:"li"},"core_parsigdb_exit_total")," will be incremented each time a voluntary exit partial signature is received, either from this node or from peers.")),(0,r.kt)("h2",{id:"self-host-a-bootnode"},"Self-Host a Bootnode"),(0,r.kt)("p",null,"If you are experiencing connectivity issues with the Obol hosted bootnode, or you want to improve your clusters latency and decentralisation, you can opt to host your own bootnode on a separate open and static internet port."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# Figure out your public IP\ncurl v4.ident.me\n\n# Clone the repo and cd into it.\ngit clone https://github.com/ObolNetwork/charon-distributed-validator-node.git\n\ncd charon-distributed-validator-node\n\n# Replace 'replace.with.public.ip.or.hostname' in bootnode/docker-compose.yml with your public IPv4 or DNS hostname # Replace 'replace.with.public.ip.or.hostname' in bootnode/docker-compose.yml with your public IPv4 or DNS hostname\n\nnano bootnode/docker-compose.yml\n\ndocker-compose -f bootnode/docker-compose.yml up\n")),(0,r.kt)("p",null,"Test whether the bootnode is publicly accessible. This should return an ENR:\n",(0,r.kt)("inlineCode",{parentName:"p"},"curl http://replace.with.public.ip.or.hostname:3640/enr")),(0,r.kt)("p",null,"Ensure the ENR returned by the bootnode contains the correct public IP and port by decoding it with ",(0,r.kt)("a",{parentName:"p",href:"https://enr-viewer.com/"},"https://enr-viewer.com/"),"."),(0,r.kt)("p",null,"Configure ",(0,r.kt)("strong",{parentName:"p"},"ALL")," charon nodes in your cluster to use this bootnode:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Either by adding a flag: ",(0,r.kt)("inlineCode",{parentName:"li"},"--p2p-bootnodes=http://replace.with.public.ip.or.hostname:3640/enr")),(0,r.kt)("li",{parentName:"ul"},"Or by setting the environment variable: ",(0,r.kt)("inlineCode",{parentName:"li"},"CHARON_P2P_BOOTNODES=http://replace.with.public.ip.or.hostname:3640/enr"))),(0,r.kt)("p",null,"Note that a local ",(0,r.kt)("inlineCode",{parentName:"p"},"boonode/.charon/charon-enr-private-key")," file will be created next to ",(0,r.kt)("inlineCode",{parentName:"p"},"bootnode/docker-compose.yml")," to ensure a persisted bootnode ENR across restarts."))}h.isMDXComponent=!0}}]);